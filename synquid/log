Checking error in
error
Adding constraint range |- {Int|0 == 0} <: {Int|False} ()
Typing Constraints
range |- {Int|0 == 0} <: {Int|False} ()
Simple Constraints
range |- {Int|0 == 0} <: {Int|False} ()
Pred assignments
Constraints
  0 == 0 ==> False
QMap
Candidates (1)
  0: [] (0 1)
Chosen candidate: 0: [] (0 1)
Invalid Constraint: 0 == 0 ==> False
Strengthening: 0 == 0 ==> False
Instantiated axioms:
All assumptions:
0 == 0
RHS: False
assumption True
mustHave 0 == 0
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
error
Adding constraint lo, range, size |- C0
Looking for type {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
Trying lo
type substitution before checking []
Checking lo :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . ??
Adding constraint lo, range, size C0 |- {Int|_v == lo} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C0 |- {Int|_v == lo} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C0
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . lo
Trying size
type substitution before checking []
Checking size :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . ??
Adding constraint lo, range, size C0 |- {Int|_v == size} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C0 |- {Int|_v == size} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C0
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . size
Adding constraint lo, range, size |- A0
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A0|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . ??
Adding constraint lo, range, size C0 |- {PList {A0|False} <False>|_v == (Nil)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C0 |- {PList {A0|False} <False>|_v == (Nil)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- A0
lo, range, size |- C0
CALL UNIFY FROM lo, range, size C0 |- {A0|False} <: {Int|lo <= _v && _v <= lo + size} ()
UNIFY A0 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U0}
Typing Constraints
Simple Constraints
lo, range, size |- C0
lo, range, size |- {Int|U0}
lo, range, size C0 |- {PList|_v == (Nil)} <: {PList|len _v == size} ()
lo, range, size C0 |- {Int|False} <: {Int|_0 != _1} ()
lo, range, size C0 |- {Int|False} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignments
addSplitConstraint lo, range, size C0 |- {PList|len _v == 0} <: {PList|len _v == size} ()
Constraints
  C0 && (len _v == 0 && size >= 0) ==> len _v == size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, U0 -> {}] (0 1)
Invalid Constraint: C0 && (len _v == 0 && size >= 0) ==> len _v == size
Strengthening: C0 && (len _v == 0 && size >= 0) ==> len _v == size
Instantiated axioms:
All assumptions:
len _v == 0, size >= 0
RHS: len _v == size
assumption len _v == 0 && size >= 0
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0, size <= lo}
{size <= 0}
Pruned valuations:
{size <= 0}
Diffs: (1)
[C0 -> {size <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, U0 -> {}] (1 0)
Typing Constraints
Simple Constraints
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, U0 -> {}] (1 0)
Auxiliary goals are:
Adding constraint lo, range, size |- C2
Trying lo
type substitution before checking []
Checking lo :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A1
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A1|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A1|False} <False>|_v == (Nil)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A1|False} <False>|_v == (Nil)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- A1
lo, range, size |- C2
CALL UNIFY FROM lo, range, size C1, C2 |- {A1|False} <: {Int|lo <= _v && _v <= lo + size} ()
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Typing Constraints
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: {PList|len _v == size} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignments
addSplitConstraint lo, range, size C1, C2 |- {PList|len _v == 0} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 0 && size >= 0)) ==> len _v == size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (1 1)
Invalid Constraint: C1 && (C2 && (len _v == 0 && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 0 && size >= 0)) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 0, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 0 && size >= 0)
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x1:Int -> {Int|_v == x1 - 1}
Trying dec
type substitution before checking []
Checking dec :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x1:Int -> {Int|_v == x1 + 1}
Trying inc
type substitution before checking []
Checking inc :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A1
Adding constraint |- P0 :: A1 -> A1 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)}
Trying Cons
type substitution before checking []
Checking Cons :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
|- P0 :: A1 -> A1 -> Bool
lo, range, size |- A1
lo, range, size |- C2
CALL UNIFY FROM lo, range, size, x1, x2 C1, C2 |- A1 /\ {Int|lo <= _v && _v <= lo + size} ()
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
X0, X1, lo, range, size C1, C2 |- {PList|_v == (Cons X1 X0)} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|[x1 -> X1, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (2 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (2 1)
Invalid Constraint: C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Strengthening: C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: lo <= _v && _v <= lo + size
assumption !(size <= 0) && size >= 0
mustHave !(lo <= _v && _v <= lo + size)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= lo + _v
          ,_v <= size + _v
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{0 <= _v, _v <= 0 + size, _v <= lo + _v, lo <= 0}
{0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 <= _v, _v <= size + lo, lo <= 0}
{_v <= 0 + size, _v <= lo + _v, lo <= 0, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{_v <= 0 + size, _v <= lo + _v, lo <= size, size <= _v}
{_v <= size + lo, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= size, size <= _v}
{_v <= 0 + size, lo <= _v, size <= lo}
{_v <= 0 + size, _v <= lo + _v, lo <= _v}
{0 <= lo, _v <= 0 + size, lo <= _v}
{_v <= size + lo, lo <= _v}
{_v <= 0 + lo, lo <= _v}
Pruned valuations:
{_v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U1 -> {_v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && ([_v -> x1]U1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons
           lo :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|_v == (Cons lo X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|[x1 -> lo, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> lo, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons lo x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && ([x1 -> lo]U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 lo _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 lo _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 lo _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size |- A2
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A2|False} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
UNIFY A2 WITH {Int|[x1 -> lo]U1 && P0 lo _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x1 -> lo, x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons lo (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x1 -> lo, x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons lo (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: {PList|len _v == size} ()
lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|[x1 -> lo, x2 -> (Nil)]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && ([x1 -> lo, x2 -> (Nil)]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && size >= 0)))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo Nil
Trying size
type substitution before checking []
Checking size :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
{0 <= lo, lo <= size}
{lo <= size, size <= lo}
Pruned valuations:
{0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons
           size :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> -> {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> -> {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> -> {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> -> {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|_v == (Cons size X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|[x1 -> size, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> size, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons size x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && ([x1 -> size]U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 size _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 size _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 size _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size |- A2
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A2|False} <: {Int|[x1 -> size]U1 && P0 size _v} ()
UNIFY A2 WITH {Int|[x1 -> size]U1 && P0 size _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons size
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x1 -> size, x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons size (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x1 -> size, x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons size (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: {PList|len _v == size} ()
lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|[x1 -> size, x2 -> (Nil)]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && ([x1 -> size, x2 -> (Nil)]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], 0 <= lo, lo <= size, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (0 <= lo && (lo <= size && size >= 0)))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U1
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == zero && (zero == 0 && size >= 0))
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons
           zero :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> -> {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> -> {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> -> {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> -> {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|_v == (Cons zero X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|[x1 -> zero, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> zero, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (zero == 0 && (_v == (Cons zero x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && ([x1 -> zero]U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 zero _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 zero _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size |- A2
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A2|False} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
UNIFY A2 WITH {Int|[x1 -> zero]U1 && P0 zero _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons zero
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x1 -> zero, x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons zero (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x1 -> zero, x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons zero (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: {PList|len _v == size} ()
lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|[x1 -> zero, x2 -> (Nil)]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && ([x1 -> zero, x2 -> (Nil)]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && size >= 0)))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero Nil
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|(_v <= size + lo && lo <= _v) && P0 zero _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|U1} ()
lo, range, size |- A2
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1}
Trying range
Adding constraint lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
lo, range, size |- C2
Simple Constraints
lo, range, size |- C2
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignments
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> _0 != _1
  False ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (len _v == size && (len _v == x1 && (size >= 0 && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
  C1 && (C2 && (_0 != _1 && size >= 0))
  C1 && (C2 && (size >= 0 && ((lo <= _v && _v <= lo + size) && ((x2 <= _v && _v <= x2 + x1) && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking range ::
X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else range
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x1:Int -> {Int|_v == x1 - 1}
Trying dec
type substitution before checking []
Checking dec :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x1:Int -> {Int|_v == x1 + 1}
Trying inc
type substitution before checking []
Checking inc :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A1
Adding constraint |- P0 :: A1 -> A1 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)}
Trying Cons
type substitution before checking []
Checking Cons :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
|- P0 :: A1 -> A1 -> Bool
lo, range, size |- A1
lo, range, size |- C2
CALL UNIFY FROM lo, range, size, x1, x2 C1, C2 |- A1 /\ {Int|lo <= _v && _v <= lo + size} ()
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
X0, X1, lo, range, size C1, C2 |- {PList|_v == (Cons X1 X0)} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|[x1 -> X1, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (2 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (2 1)
Invalid Constraint: C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Strengthening: C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: lo <= _v && _v <= lo + size
assumption !(size <= 0) && size >= 0
mustHave !(lo <= _v && _v <= lo + size)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= lo + _v
          ,_v <= size + _v
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{0 <= _v, _v <= 0 + size, _v <= lo + _v, lo <= 0}
{0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 <= _v, _v <= size + lo, lo <= 0}
{_v <= 0 + size, _v <= lo + _v, lo <= 0, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{_v <= 0 + size, _v <= lo + _v, lo <= size, size <= _v}
{_v <= size + lo, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= size, size <= _v}
{_v <= 0 + size, lo <= _v, size <= lo}
{_v <= 0 + size, _v <= lo + _v, lo <= _v}
{0 <= lo, _v <= 0 + size, lo <= _v}
{_v <= size + lo, lo <= _v}
{_v <= 0 + lo, lo <= _v}
Pruned valuations:
{_v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U1 -> {_v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && ([_v -> x1]U1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons
           lo :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|_v == (Cons lo X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|[x1 -> lo, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> lo, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons lo x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && ([x1 -> lo]U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
type substitution before checking []
Checking dec :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && P0 lo _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
type substitution before checking []
Checking inc :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && P0 lo _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
type substitution before checking []
Checking Cons :: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x3, x4 C1, C2 |- A2 /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
UNIFY A2 WITH {Int|[x1 -> lo]U1 && P0 lo _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Trying size
type substitution before checking []
Checking size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           size :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons size X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> size]U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> size]U2 && P1 size _v} ()
UNIFY A3 WITH {Int|[x3 -> size]U2 && P1 size _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons size
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size Nil)
Trying lo
type substitution before checking []
Checking lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           lo :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons lo X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> lo]U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
UNIFY A3 WITH {Int|[x3 -> lo]U2 && P1 lo _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons lo
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo Nil)
Trying zero
type substitution before checking []
Checking zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           zero :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons zero X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> zero]U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
UNIFY A3 WITH {Int|[x3 -> zero]U2 && P1 zero _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons zero
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
lo, range, size |- A3
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x1 -> lo]U1 && P0 lo _v) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x1 -> lo]U1 && P0 lo _v) && (x4 <= _v && _v <= x4 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo
                    size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo size)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo
                    lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo lo)
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo
                    zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x1 -> lo]U1 && P0 lo _v) && (x4 <= _v && _v <= x4 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero size)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero lo)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying size
type substitution before checking []
Checking size :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
{0 <= lo, lo <= size}
{lo <= size, size <= lo}
Pruned valuations:
{0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons
           size :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> -> {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> -> {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> -> {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> -> {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|_v == (Cons size X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|[x1 -> size, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> size, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons size x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && ([x1 -> size]U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
type substitution before checking []
Checking dec :: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && P0 size _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
type substitution before checking []
Checking inc :: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && P0 size _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
type substitution before checking []
Checking Cons :: X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x3, x4 C1, C2 |- A2 /\ {Int|[x1 -> size]U1 && P0 size _v} ()
UNIFY A2 WITH {Int|[x1 -> size]U1 && P0 size _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> size]U1 && P0 size _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           lo :: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons lo X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} /\ {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> lo]U2 && (size >= 0 && ([x1 -> size]U1 && P0 size _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
UNIFY A3 WITH {Int|[x3 -> lo]U2 && P1 lo _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo
           Nil :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size (Cons lo
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (Cons lo
                           Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo Nil)
Trying size
type substitution before checking []
Checking size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           size :: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons size X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} /\ {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> size]U2 && (size >= 0 && ([x1 -> size]U1 && P0 size _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> size]U2 && P1 size _v} ()
UNIFY A3 WITH {Int|[x3 -> size]U2 && P1 size _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size
           Nil :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size (Cons size
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (Cons
                           size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons size Nil)
Trying zero
type substitution before checking []
Checking zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           zero :: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons zero X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} /\ {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> zero]U2 && (size >= 0 && ([x1 -> size]U1 && P0 size _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
UNIFY A3 WITH {Int|[x3 -> zero]U2 && P1 zero _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero
           Nil :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size (Cons zero
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (Cons
                           zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
lo, range, size |- A3
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x1 -> size]U1 && P0 size _v) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
{lo <= 0}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x1 -> size]U1 && P0 size _v) && (x4 <= _v && _v <= x4 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons size (range lo
                      lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo lo)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons size (range lo
                      size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           lo size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo size)
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons size (range lo
                      zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x1 -> size]U1 && P0 size _v) && (x4 <= _v && _v <= x4 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons size (range zero
                      lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero lo)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons size (range zero
                      size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> size]U1 && P0 size _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons size (range zero
                      zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> size]U1} <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> size]U1 && P0 size _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> size]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> size]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> size]U1 && P0 size _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U1
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == zero && (zero == 0 && size >= 0))
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons
           zero :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> -> {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> -> {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> -> {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> -> {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|_v == (Cons zero X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|[x1 -> zero, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> zero, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (zero == 0 && (_v == (Cons zero x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && ([x1 -> zero]U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
type substitution before checking []
Checking dec :: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && P0 zero _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
type substitution before checking []
Checking inc :: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && P0 zero _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
type substitution before checking []
Checking Cons :: X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x3, x4 C1, C2 |- A2 /\ {Int|[x1 -> zero]U1 && P0 zero _v} ()
UNIFY A2 WITH {Int|[x1 -> zero]U1 && P0 zero _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (zero == 0 && (size >= 0 && ([x1 -> zero]U1 && P0 zero _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           lo :: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons lo X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} /\ {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> lo]U2 && (zero == 0 && (size >= 0 && ([x1 -> zero]U1 && P0 zero _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
UNIFY A3 WITH {Int|[x3 -> lo]U2 && P1 lo _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo
           Nil :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero (Cons lo
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> lo, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (Cons lo
                           Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons lo Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Trying size
type substitution before checking []
Checking size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           size :: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons size X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} /\ {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> size]U2 && (zero == 0 && (size >= 0 && ([x1 -> zero]U1 && P0 zero _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> size]U2 && P1 size _v} ()
UNIFY A3 WITH {Int|[x3 -> size]U2 && P1 size _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size
           Nil :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero (Cons size
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> size, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (Cons
                           size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
lo, range, size |- A3
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           zero :: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons zero X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} /\ {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> zero]U2 && (zero == 0 && (size >= 0 && ([x1 -> zero]U1 && P0 zero _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
UNIFY A3 WITH {Int|[x3 -> zero]U2 && P1 zero _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero
           Nil :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero (Cons zero
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x3 -> zero, x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> (Nil)]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (Cons
                           zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons zero Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x1 -> zero]U1 && P0 zero _v) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x1 -> zero]U1 && P0 zero _v) && (x4 <= _v && _v <= x4 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons zero (range lo
                      size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (range
                           lo size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo size)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons zero (range lo
                      lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (range
                           lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo lo)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons zero (range lo
                      zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (range
                           lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo zero)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= 0, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x1 -> zero]U1 && P0 zero _v) && (x4 <= _v && _v <= x4 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons zero (range zero
                      lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (range
                           zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero lo)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons zero (range zero
                      size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (range
                           zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> zero]U1 && P0 zero _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons zero (range zero
                      zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> zero]U1} <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x1 -> zero]U1 && P0 zero _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> zero]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> zero]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (range
                           zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|U1} ()
lo, range, size |- A2
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1}
Trying range
Adding constraint lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
lo, range, size |- C2
Simple Constraints
lo, range, size |- C2
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignments
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> _0 != _1
  False ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (len _v == size && (len _v == x1 && (size >= 0 && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
  C1 && (C2 && (_0 != _1 && size >= 0))
  C1 && (C2 && (size >= 0 && ((lo <= _v && _v <= lo + size) && ((x2 <= _v && _v <= x2 + x1) && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking range ::
X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else range
Adding constraint lo, range, size |- A1
Adding constraint |- P0 :: A1 -> A1 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)}
Trying Cons
type substitution before checking []
Checking Cons :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
|- P0 :: A1 -> A1 -> Bool
lo, range, size |- A1
lo, range, size |- C2
CALL UNIFY FROM lo, range, size, x1, x2 C1, C2 |- A1 /\ {Int|lo <= _v && _v <= lo + size} ()
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
X0, X1, lo, range, size C1, C2 |- {PList|_v == (Cons X1 X0)} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|[x1 -> X1, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (2 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (2 1)
Invalid Constraint: C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Strengthening: C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: lo <= _v && _v <= lo + size
assumption !(size <= 0) && size >= 0
mustHave !(lo <= _v && _v <= lo + size)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= lo + _v
          ,_v <= size + _v
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{0 <= _v, _v <= size + lo, lo <= 0}
{0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 <= _v, _v <= 0 + size, _v <= lo + _v, lo <= 0}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{_v <= 0 + size, _v <= lo + _v, lo <= 0, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{_v <= 0 + size, _v <= lo + _v, lo <= size, size <= _v}
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{_v <= size + lo, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= size, size <= _v}
{_v <= 0 + size, lo <= _v, size <= lo}
{_v <= 0 + size, _v <= lo + _v, lo <= _v}
{_v <= size + lo, lo <= _v}
{0 <= lo, _v <= 0 + size, lo <= _v}
{_v <= 0 + lo, lo <= _v}
Pruned valuations:
{_v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U1 -> {_v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && ([_v -> x1]U1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
type substitution before checking []
Checking dec :: X2:_ -> {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> {Int|U1} ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> {Int|U1} ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, lo, range, size C1, C2 |- {Int|_v == X2 - 1} <: {Int|U1} ()
lo, range, size, x3 C1, C2 |- {Int|_v == x3 - 1} /\ {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  False ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (U1 && (_v == x3 - 1 && size >= 0)))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking dec lo :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo - 1, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == lo - 1 && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking dec lo ::
{Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec lo
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking dec size :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size - 1 && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == size - 1 && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == size - 1 && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size - 1, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == size - 1 && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (dec
                 size) :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 X0)} <: {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|[x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (x1 == size - 1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size |- A2
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x1 C1, C2 |- {A2|False} <: {Int|U1 && P0 x1 _v} ()
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
lo, range, size, x1 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons (dec size)
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x1:({Int|_v == size - 1}) IN {PList {Int|[x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x1:({Int|_v == size - 1}) IN {PList {Int|[x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 (Nil))} <: {PList|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x2 -> (Nil)]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && ([x2 -> (Nil)]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], size != lo, 0 <= lo, lo <= size, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (size != lo && (0 <= lo && (lo <= size && size >= 0))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) Nil
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x4:Int -> {Int|_v == x4 + 1}
Trying inc
type substitution before checking []
Checking inc :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X3:_ -> x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x4:Int -> {Int|_v == x4 - 1}
Trying dec
type substitution before checking []
Checking dec :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X3:_ -> x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)}
Trying Cons
type substitution before checking []
Checking Cons :: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x1, x4, x5 C1, C2 |- A2 /\ {Int|U1 && P0 x1 _v} ()
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X3, X4, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons X4 X3)} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|_v == (Cons x4 x5)} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (x1 == size - 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           lo :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons lo x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> lo]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> lo]U2 && (x1 == size - 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> lo]U2 && P1 lo _v} ()
UNIFY A3 WITH {Int|[x4 -> lo]U2 && P1 lo _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo
           Nil :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (dec size) (Cons
                            lo
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (Cons lo Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons lo
                              Nil)
Trying size
type substitution before checking []
Checking size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           size :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons size x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> size]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> size]U2 && (x1 == size - 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> size]U2 && P1 size _v} ()
UNIFY A3 WITH {Int|[x4 -> size]U2 && P1 size _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size
           Nil :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (dec size) (Cons
                            size
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (Cons size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              Nil)
Trying zero
type substitution before checking []
Checking zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           zero :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons zero x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> zero]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> zero]U2 && (x1 == size - 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> zero]U2 && P1 zero _v} ()
UNIFY A3 WITH {Int|[x4 -> zero]U2 && P1 zero _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero
           Nil :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (dec size) (Cons
                            zero
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (Cons zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons zero
                              Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
lo, range, size |- A3
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4}
Trying range
Adding constraint lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X3, X4, lo, range, size, x1 C1, C2 |- {PList|len _v == X4} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|len _v == x4} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == size - 1 && (size >= 0 && ((U1 && P0 x1 _v) && ((x5 <= _v && _v <= x5 + x4) && (x4 >= 0 && (x4 >= 0 && x4 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == size - 1 && (size >= 0 && ((U1 && P0 x1 _v) && (x5 <= _v && _v <= x5 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (dec size) (range
                            lo
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (range lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              lo)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (dec size) (range
                            lo
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (range lo size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              size)
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (dec size) (range
                            lo
                            zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (range lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (size != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && ((U1 && P0 x1 _v) && (x5 <= _v && _v <= x5 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (dec size) (range
                            zero
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (range zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              lo)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (dec size) (range
                            zero
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (range zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (dec size) (range
                            zero
                            zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size - 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (range zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking dec zero :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> U1
Strengthening: C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero - 1, zero == 0, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == zero - 1 && (zero == 0 && size >= 0))
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking dec zero ::
{Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
type substitution before checking []
Checking inc :: X2:_ -> {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> {Int|U1} ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> {Int|U1} ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, lo, range, size C1, C2 |- {Int|_v == X2 + 1} <: {Int|U1} ()
lo, range, size, x3 C1, C2 |- {Int|_v == x3 + 1} /\ {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  False ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (U1 && (_v == x3 + 1 && size >= 0)))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking inc lo :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo + 1 && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc
                 lo) :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 X0)} <: {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|[x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (x1 == lo + 1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size |- A2
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x1 C1, C2 |- {A2|False} <: {Int|U1 && P0 x1 _v} ()
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
lo, range, size, x1 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons (inc lo)
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x1:({Int|_v == lo + 1}) IN {PList {Int|[x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x1:({Int|_v == lo + 1}) IN {PList {Int|[x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 (Nil))} <: {PList|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x2 -> (Nil)]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && ([x2 -> (Nil)]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && size >= 0)))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo) Nil
::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) Nil
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x4:Int -> {Int|_v == x4 - 1}
Trying dec
type substitution before checking []
Checking dec :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X3:_ -> x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x4:Int -> {Int|_v == x4 + 1}
Trying inc
type substitution before checking []
Checking inc :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X3:_ -> x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)}
Trying Cons
type substitution before checking []
Checking Cons :: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x1, x4, x5 C1, C2 |- A2 /\ {Int|U1 && P0 x1 _v} ()
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X3, X4, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons X4 X3)} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|_v == (Cons x4 x5)} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (x1 == lo + 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           size :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons size x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> size]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> size]U2 && (x1 == lo + 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> size]U2 && P1 size _v} ()
UNIFY A3 WITH {Int|[x4 -> size]U2 && P1 size _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size
           Nil :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc lo) (Cons
                          size
                          Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (Cons size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            Nil)
Trying lo
type substitution before checking []
Checking lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           lo :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons lo x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> lo]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> lo]U2 && (x1 == lo + 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> lo]U2 && P1 lo _v} ()
UNIFY A3 WITH {Int|[x4 -> lo]U2 && P1 lo _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo
           Nil :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc lo) (Cons lo
                          Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (Cons lo Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo Nil)
Trying zero
type substitution before checking []
Checking zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           zero :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons zero x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> zero]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> zero]U2 && (x1 == lo + 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> zero]U2 && P1 zero _v} ()
UNIFY A3 WITH {Int|[x4 -> zero]U2 && P1 zero _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero
           Nil :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc lo) (Cons
                          zero
                          Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (Cons zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
lo, range, size |- A3
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4}
Trying range
Adding constraint lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X3, X4, lo, range, size, x1 C1, C2 |- {PList|len _v == X4} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|len _v == x4} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == lo + 1 && (size >= 0 && ((U1 && P0 x1 _v) && ((x5 <= _v && _v <= x5 + x4) && (x4 >= 0 && (x4 >= 0 && x4 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == lo + 1 && (size >= 0 && ((U1 && P0 x1 _v) && (x5 <= _v && _v <= x5 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc lo) (range lo
                          size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range lo size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo
                            size)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc lo) (range lo
                          lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo lo)
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc lo) (range lo
                          zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo
                            zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && ((U1 && P0 x1 _v) && (x5 <= _v && _v <= x5 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc lo) (range
                          zero
                          size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            size)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc lo) (range
                          zero
                          lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            lo)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc lo) (range
                          zero
                          zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking inc size :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size + 1 && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == size + 1 && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == size + 1 && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size + 1, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == size + 1 && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, 0 <= lo, lo <= size}
{lo <= size, size <= lo}
Pruned valuations:
{0 != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {0 != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument inc
                       size of type {Int|_v == size + 1}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc
                 size) :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 X0)} <: {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|[x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (x1 == size + 1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size |- A2
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x1 C1, C2 |- {A2|False} <: {Int|U1 && P0 x1 _v} ()
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
lo, range, size, x1 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons (inc size)
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x1:({Int|_v == size + 1}) IN {PList {Int|[x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x1:({Int|_v == size + 1}) IN {PList {Int|[x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 (Nil))} <: {PList|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x2 -> (Nil)]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && ([x2 -> (Nil)]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) Nil
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x4:Int -> {Int|_v == x4 - 1}
Trying dec
type substitution before checking []
Checking dec :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X3:_ -> x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x4:Int -> {Int|_v == x4 + 1}
Trying inc
type substitution before checking []
Checking inc :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X3:_ -> x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)}
Trying Cons
type substitution before checking []
Checking Cons :: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x1, x4, x5 C1, C2 |- A2 /\ {Int|U1 && P0 x1 _v} ()
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X3, X4, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons X4 X3)} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|_v == (Cons x4 x5)} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (x1 == size + 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           lo :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons lo x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> lo]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> lo]U2 && (x1 == size + 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> lo]U2 && P1 lo _v} ()
UNIFY A3 WITH {Int|[x4 -> lo]U2 && P1 lo _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo
           Nil :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc size) (Cons
                            lo
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (Cons lo Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              Nil)
Trying size
type substitution before checking []
Checking size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           size :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons size x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> size]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> size]U2 && (x1 == size + 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> size]U2 && P1 size _v} ()
UNIFY A3 WITH {Int|[x4 -> size]U2 && P1 size _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size
           Nil :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc size) (Cons
                            size
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (Cons size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              Nil)
Trying zero
type substitution before checking []
Checking zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           zero :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons zero x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> zero]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> zero]U2 && (x1 == size + 1 && (size >= 0 && (U1 && P0 x1 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> zero]U2 && P1 zero _v} ()
UNIFY A3 WITH {Int|[x4 -> zero]U2 && P1 zero _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero
           Nil :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc size) (Cons
                            zero
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (Cons zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons zero
                              Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
lo, range, size |- A3
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4}
Trying range
Adding constraint lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X3, X4, lo, range, size, x1 C1, C2 |- {PList|len _v == X4} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|len _v == x4} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == size + 1 && (size >= 0 && ((U1 && P0 x1 _v) && ((x5 <= _v && _v <= x5 + x4) && (x4 >= 0 && (x4 >= 0 && x4 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == size + 1 && (size >= 0 && ((U1 && P0 x1 _v) && (x5 <= _v && _v <= x5 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc size) (range
                            lo
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, 0 != lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (0 != lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (range lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              lo)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc size) (range
                            lo
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, 0 != lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (0 != lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (range lo size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              size)
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc size) (range
                            lo
                            zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, 0 != lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (0 != lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (range lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && ((U1 && P0 x1 _v) && (x5 <= _v && _v <= x5 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc size) (range
                            zero
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (range zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              lo)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc size) (range
                            zero
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (range zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc size) (range
                            zero
                            zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (range zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking inc zero :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> U1
Strengthening: C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero + 1, zero == 0, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == zero + 1 && (zero == 0 && size >= 0))
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument inc
                       zero of type {Int|_v == zero + 1}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc
                 zero) :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 X0)} <: {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|[x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0))))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size |- A2
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x1 C1, C2 |- {A2|False} <: {Int|U1 && P0 x1 _v} ()
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
lo, range, size, x1 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons (inc zero)
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x1:({Int|_v == zero + 1}) IN {PList {Int|[x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x1:({Int|_v == zero + 1}) IN {PList {Int|[x2 -> (Nil)]U1} <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 (Nil))} <: {PList|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x2 -> (Nil)]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && ([x2 -> (Nil)]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && size >= 0)))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) Nil
Trying zero
type substitution before checking []
Checking zero :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x4:Int -> {Int|_v == x4 - 1}
Trying dec
type substitution before checking []
Checking dec :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X3:_ -> x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x4:Int -> {Int|_v == x4 + 1}
Trying inc
type substitution before checking []
Checking inc :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X3:_ -> x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && P0 x1 _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)}
Trying Cons
type substitution before checking []
Checking Cons :: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x1, x4, x5 C1, C2 |- A2 /\ {Int|U1 && P0 x1 _v} ()
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X3, X4, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons X4 X3)} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|_v == (Cons x4 x5)} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (U1 && P0 x1 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           lo :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x4 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons lo x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> lo]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> lo]U2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (U1 && P0 x1 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> lo]U2 && P1 lo _v} ()
UNIFY A3 WITH {Int|[x4 -> lo]U2 && P1 lo _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo
           Nil :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc zero) (Cons
                            lo
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> lo, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (Cons lo Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> lo, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Trying size
type substitution before checking []
Checking size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           size :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x4 -> size]U2} <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons size x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> size]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> size]U2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (U1 && P0 x1 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> size]U2 && P1 size _v} ()
UNIFY A3 WITH {Int|[x4 -> size]U2 && P1 size _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons size
           Nil :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc zero) (Cons
                            size
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> size, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (Cons size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons size
                              Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> size, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
lo, range, size |- A3
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           zero :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x4 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons zero x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|[x4 -> zero]U2} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x4 -> zero]U2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (U1 && P0 x1 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A3|False} <: {Int|[x4 -> zero]U2 && P1 zero _v} ()
UNIFY A3 WITH {Int|[x4 -> zero]U2 && P1 zero _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x4 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons zero
           Nil :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc zero) (Cons
                            zero
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|[x4 -> zero, x5 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> (Nil)]U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (Cons zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              Nil)
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x4 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|[x4 -> zero, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|[x4 -> X4, x5 -> X3]U2} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4}
Trying range
Adding constraint lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X3, X4, lo, range, size, x1 C1, C2 |- {PList|len _v == X4} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|len _v == x4} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && ((U1 && P0 x1 _v) && ((x5 <= _v && _v <= x5 + x4) && (x4 >= 0 && (x4 >= 0 && x4 < size))))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && ((U1 && P0 x1 _v) && (x5 <= _v && _v <= x5 + lo))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc zero) (range
                            lo
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range lo size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              size)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc zero) (range
                            lo
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              lo)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc zero) (range
                            lo
                            zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              zero)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= 0, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && ((U1 && P0 x1 _v) && (x5 <= _v && _v <= x5 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc zero) (range
                            zero
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              lo)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc zero) (range
                            zero
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {Int|U1 && P0 x1 _v} <P0 _0 _1> ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons (inc zero) (range
                            zero
                            zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList {Int|U1} <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
type substitution before checking []
Checking Cons :: X3:_ -> X2:_ -> {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> {Int|U1} ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> {Int|U1} ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> {Int|U1} ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> {Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X3:_ -> X2:_ -> {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> {Int|U1} ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> {Int|U1} ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> {Int|U1} ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (Int) <()>'
with shape 'Int'
when checking range ::
X3:_ -> X2:_ -> {Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else range
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1}
Trying range
Adding constraint lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
lo, range, size |- C2
Simple Constraints
lo, range, size |- C2
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignments
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> _0 != _1
  False ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (len _v == size && (len _v == x1 && (size >= 0 && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
  C1 && (C2 && (_0 != _1 && size >= 0))
  C1 && (C2 && (size >= 0 && ((lo <= _v && _v <= lo + size) && ((x2 <= _v && _v <= x2 + x1) && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking range ::
X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else range
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x1:Int -> {Int|_v == x1 - 1}
Trying dec
type substitution before checking []
Checking dec :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x1:Int -> {Int|_v == x1 + 1}
Trying inc
type substitution before checking []
Checking inc :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A1
Adding constraint |- P0 :: A1 -> A1 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)}
Trying Cons
type substitution before checking []
Checking Cons :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
|- P0 :: A1 -> A1 -> Bool
lo, range, size |- A1
lo, range, size |- C2
CALL UNIFY FROM lo, range, size, x1, x2 C1, C2 |- A1 /\ {Int|lo <= _v && _v <= lo + size} ()
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
X0, X1, lo, range, size C1, C2 |- {PList|_v == (Cons X1 X0)} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|[x1 -> X1, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (2 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (2 1)
Invalid Constraint: C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Strengthening: C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: lo <= _v && _v <= lo + size
assumption !(size <= 0) && size >= 0
mustHave !(lo <= _v && _v <= lo + size)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= lo + _v
          ,_v <= size + _v
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{_v <= 0 + size, _v <= lo + _v, lo <= 0, size <= _v}
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= _v, _v <= 0 + size, _v <= lo + _v, lo <= 0}
{0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 <= _v, _v <= size + lo, lo <= 0}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{_v <= 0 + size, _v <= lo + _v, lo <= size, size <= _v}
{_v <= size + lo, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= size, size <= _v}
{_v <= 0 + size, lo <= _v, size <= lo}
{_v <= 0 + size, _v <= lo + _v, lo <= _v}
{0 <= lo, _v <= 0 + size, lo <= _v}
{_v <= size + lo, lo <= _v}
{_v <= 0 + lo, lo <= _v}
Pruned valuations:
{_v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U1 -> {_v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && ([_v -> x1]U1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (3 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U1} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons
           lo :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> -> {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|_v == (Cons lo X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|[x1 -> lo, x2 -> X0]U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} /\ {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && ([x1 -> lo, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons lo x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && ([x1 -> lo]U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
type substitution before checking []
Checking dec :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && P0 lo _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
type substitution before checking []
Checking inc :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && P0 lo _v} <P0 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
type substitution before checking []
Checking Cons :: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x3, x4 C1, C2 |- A2 /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
UNIFY A2 WITH {Int|[x1 -> lo]U1 && P0 lo _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Trying size
type substitution before checking []
Checking size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           size :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> -> {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons size X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> size]U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
type substitution before checking []
Checking dec :: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X4:_ -> PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
type substitution before checking []
Checking inc :: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X4:_ -> PList {Int|True && P1 size _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
type substitution before checking []
Checking Cons :: X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x5, x6 C1, C2 |- A3 /\ {Int|[x3 -> size]U2 && P1 size _v} ()
UNIFY A3 WITH {Int|[x3 -> size]U2 && P1 size _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X4, X5, lo, range, size C1, C2 |- {PList|_v == (Cons X5 X4)} <: PList ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x5, x6 C1, C2 |- {PList|_v == (Cons x5 x6)} /\ PList ()
lo, range, size, x5, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|U3} /\ {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (size >= 0 && ([x3 -> size]U2 && P1 size _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons lo X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons lo x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> lo]U3} /\ {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> lo]U3 && (size >= 0 && ([x3 -> size]U2 && P1 size _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x5 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size (Cons lo
                      Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons size
                       (Cons lo
                          Nil) of type LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons size
                    (Cons lo
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons size x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons size x4)) == [size] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons size x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons size x4)) == [size] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len ((Cons size x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems ((Cons size x4)) == [size] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons lo
                                 Nil))
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons size X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons size x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> size]U3} /\ {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> size]U3 && (size >= 0 && ([x3 -> size]U2 && P1 size _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x5 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size (Cons size
                      Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons size
                       (Cons size
                          Nil) of type LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons size
                    (Cons size
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
Instantiated axioms:
len ((Cons size x4)) == 1 + len x4, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size x4)) == [size] + elems x4, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size x4)) == 1 + len x4, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size x4)) == [size] + elems x4, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size x4)) == 1 + len x4 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size x4)) == [size] + elems x4 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons
                                 size Nil))
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons zero X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons zero x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> zero]U3} /\ {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> zero]U3 && (size >= 0 && ([x3 -> size]U2 && P1 size _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x5 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size (Cons zero
                      Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons size
                       (Cons zero
                          Nil) of type LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons size
                    (Cons zero
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size x4)) == [size] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons size x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons size x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size x4)) == [size] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons size x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons size x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size x4)) == [size] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons
                                 zero Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X4, X5, lo, range, size C1, C2 |- {PList|len _v == X5} <: PList ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x5, x6 C1, C2 |- {PList|len _v == x5} /\ PList ()
lo, range, size, x5, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + x5} /\ {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x3 -> size]U2 && P1 size _v) && ((x6 <= _v && _v <= x6 + x5) && (x5 >= 0 && (x5 >= 0 && x5 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x6 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + lo} /\ {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x3 -> size]U2 && P1 size _v) && (x6 <= _v && _v <= x6 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons size (range lo
                      size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons size
                       (range lo
                          size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons size
                    (range lo
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4
All assumptions:
!(size <= 0), x2 == (Cons size x4), len _v == 1 + len x2, len x4 == lo, len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons size x4)) == 1 + len x4 && (elems ((Cons size x4)) == [size] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons size (range lo
                      lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons size
                       (range lo
                          lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons size
                    (range lo
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4
All assumptions:
!(size <= 0), x2 == (Cons size x4), len _v == 1 + len x2, len x4 == lo, len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons size x4)) == 1 + len x4 && (elems ((Cons size x4)) == [size] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo lo))
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons size (range lo
                      zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons size
                       (range lo
                          zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons size
                    (range lo
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons size x4), len _v == 1 + len x2, len x4 == lo, len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons size x4)) == 1 + len x4 && (elems ((Cons size x4)) == [size] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} /\ X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} <: X4:_ -> PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x6 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + zero} /\ {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x3 -> size]U2 && P1 size _v) && (x6 <= _v && _v <= x6 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons size (range zero
                      lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons size
                       (range zero
                          lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons size
                    (range zero
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons size x4), len _v == 1 + len x2, len x4 == zero, len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons size x4)) == 1 + len x4 && (elems ((Cons size x4)) == [size] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero lo))
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons size (range zero
                      size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons size
                       (range zero
                          size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons size
                    (range zero
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons size x4), len _v == 1 + len x2, len x4 == zero, len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons size x4)) == 1 + len x4 && (elems ((Cons size x4)) == [size] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero size))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> size]U2 && P1 size _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons size (range zero
                      zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons size
                       (range zero
                          zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons size
                    (range zero
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> size]U2} <P1 _0 _1>|_v == (Cons size x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> size]U2 && P1 size _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> size]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons size x4), len _v == 1 + len x2, len x4 == zero, len ((Cons size x4)) == 1 + len x4, elems ((Cons size x4)) == [size] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons size x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons size x4)) == 1 + len x4 && (elems ((Cons size x4)) == [size] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> size]U2 && P1 size _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> size, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying lo
type substitution before checking []
Checking lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           lo :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> -> {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons lo X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> lo]U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
type substitution before checking []
Checking dec :: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X4:_ -> PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
type substitution before checking []
Checking inc :: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X4:_ -> PList {Int|True && P1 lo _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
type substitution before checking []
Checking Cons :: X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x5, x6 C1, C2 |- A3 /\ {Int|[x3 -> lo]U2 && P1 lo _v} ()
UNIFY A3 WITH {Int|[x3 -> lo]U2 && P1 lo _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X4, X5, lo, range, size C1, C2 |- {PList|_v == (Cons X5 X4)} <: PList ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x5, x6 C1, C2 |- {PList|_v == (Cons x5 x6)} /\ PList ()
lo, range, size, x5, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|U3} /\ {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (size >= 0 && ([x3 -> lo]U2 && P1 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons size X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons size x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> size]U3} /\ {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> size]U3 && (size >= 0 && ([x3 -> lo]U2 && P1 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x5 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons size
                    Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons lo
                       (Cons size
                          Nil) of type LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons lo (Cons
                             size
                             Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo x4)) == [lo] + elems x4, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons lo x4)) == 1 + len x4, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo x4)) == [lo] + elems x4, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo x4)) == 1 + len x4 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo x4)) == [lo] + elems x4 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (Cons size
                               Nil))
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons lo X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons lo x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> lo]U3} /\ {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> lo]U3 && (size >= 0 && ([x3 -> lo]U2 && P1 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x5 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons lo
                    Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons lo
                       (Cons lo
                          Nil) of type LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons lo (Cons
                             lo
                             Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo x4)) == [lo] + elems x4, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo x4)) == 1 + len x4, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo x4)) == [lo] + elems x4, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo x4)) == 1 + len x4 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo x4)) == [lo] + elems x4 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (Cons lo
                               Nil))
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons zero X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons zero x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> zero]U3} /\ {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> zero]U3 && (size >= 0 && ([x3 -> lo]U2 && P1 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x5 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons zero
                    Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons lo
                       (Cons zero
                          Nil) of type LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons lo (Cons
                             zero
                             Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo x4)) == [lo] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons lo x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons lo x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo x4)) == [lo] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons lo x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo x4)) == [lo] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (Cons zero
                               Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X4, X5, lo, range, size C1, C2 |- {PList|len _v == X5} <: PList ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x5, x6 C1, C2 |- {PList|len _v == x5} /\ PList ()
lo, range, size, x5, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + x5} /\ {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x3 -> lo]U2 && P1 lo _v) && ((x6 <= _v && _v <= x6 + x5) && (x5 >= 0 && (x5 >= 0 && x5 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x6 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + lo} /\ {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x3 -> lo]U2 && P1 lo _v) && (x6 <= _v && _v <= x6 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons lo (range lo
                    size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons lo
                       (range lo
                          size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons lo (range
                             lo
                             size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4
All assumptions:
!(size <= 0), x2 == (Cons lo x4), len _v == 1 + len x2, len x4 == lo, len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons lo x4)) == 1 + len x4 && (elems ((Cons lo x4)) == [lo] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (range lo
                               size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons lo (range lo
                    lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons lo
                       (range lo
                          lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons lo (range
                             lo
                             lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4
All assumptions:
!(size <= 0), x2 == (Cons lo x4), len _v == 1 + len x2, len x4 == lo, len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons lo x4)) == 1 + len x4 && (elems ((Cons lo x4)) == [lo] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (range lo
                               lo))
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons lo (range lo
                    zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons lo
                       (range lo
                          zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons lo (range
                             lo
                             zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons lo x4), len _v == 1 + len x2, len x4 == lo, len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons lo x4)) == 1 + len x4 && (elems ((Cons lo x4)) == [lo] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (range lo
                               zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} /\ X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} <: X4:_ -> PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x6 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + zero} /\ {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x3 -> lo]U2 && P1 lo _v) && (x6 <= _v && _v <= x6 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons lo (range zero
                    size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons lo
                       (range zero
                          size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons lo (range
                             zero
                             size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons lo x4), len _v == 1 + len x2, len x4 == zero, len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons lo x4)) == 1 + len x4 && (elems ((Cons lo x4)) == [lo] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (range
                               zero size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons lo (range zero
                    lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons lo
                       (range zero
                          lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons lo (range
                             zero
                             lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons lo x4), len _v == 1 + len x2, len x4 == zero, len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons lo x4)) == 1 + len x4 && (elems ((Cons lo x4)) == [lo] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (range
                               zero lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> lo]U2 && P1 lo _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons lo (range zero
                    zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons lo
                       (range zero
                          zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons lo (range
                             zero
                             zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> lo]U2} <P1 _0 _1>|_v == (Cons lo x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> lo]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons lo x4), len _v == 1 + len x2, len x4 == zero, len ((Cons lo x4)) == 1 + len x4, elems ((Cons lo x4)) == [lo] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons lo x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons lo x4)) == 1 + len x4 && (elems ((Cons lo x4)) == [lo] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons lo
                         (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo (range
                               zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> lo]U2 && P1 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> lo, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons
           zero :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> -> {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|_v == (Cons zero X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && ([x3 -> zero]U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
type substitution before checking []
Checking dec :: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X4:_ -> PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
type substitution before checking []
Checking inc :: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X4:_ -> PList {Int|True && P1 zero _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
type substitution before checking []
Checking Cons :: X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x5, x6 C1, C2 |- A3 /\ {Int|[x3 -> zero]U2 && P1 zero _v} ()
UNIFY A3 WITH {Int|[x3 -> zero]U2 && P1 zero _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X4, X5, lo, range, size C1, C2 |- {PList|_v == (Cons X5 X4)} <: PList ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x5, x6 C1, C2 |- {PList|_v == (Cons x5 x6)} /\ PList ()
lo, range, size, x5, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|U3} /\ {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (zero == 0 && (size >= 0 && ([x3 -> zero]U2 && P1 zero _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x5 -> size]U3} <P2 _0 _1>|_v == (Cons size x6)} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons size X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons size x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> size]U3} /\ {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> size]U3 && (zero == 0 && (size >= 0 && ([x3 -> zero]U2 && P1 zero _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x5 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero (Cons size
                      Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons zero
                       (Cons size
                          Nil) of type LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons zero
                    (Cons size
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> size, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons zero x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons zero x4)) == [zero] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons zero x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons zero x4)) == [zero] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len ((Cons zero x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems ((Cons zero x4)) == [zero] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (Cons
                                 size Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> size, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x5 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x6)} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons lo X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons lo x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> lo]U3} /\ {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> lo]U3 && (zero == 0 && (size >= 0 && ([x3 -> zero]U2 && P1 zero _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x5 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero (Cons lo
                      Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons zero
                       (Cons lo
                          Nil) of type LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons zero
                    (Cons lo
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> lo, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons zero x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons zero x4)) == [zero] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons zero x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons zero x4)) == [zero] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len ((Cons zero x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems ((Cons zero x4)) == [zero] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (Cons lo
                                 Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> lo, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x5 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x6)} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {PList|_v == (Cons zero X4)} <: PList ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x6 C1, C2 |- {PList|_v == (Cons zero x6)} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|[x5 -> zero]U3} /\ {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x5 -> zero]U3 && (zero == 0 && (size >= 0 && ([x3 -> zero]U2 && P1 zero _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x5 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x5 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x5 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero (Cons zero
                      Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons zero
                       (Cons zero
                          Nil) of type LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons zero
                    (Cons zero
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x5 -> zero, x6 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> (Nil)]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero x4)) == [zero] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero x4)) == [zero] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero x4)) == [zero] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (Cons
                                 zero Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x5 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|[x5 -> zero, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|[x5 -> X5, x6 -> X4]U3} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X4, X5, lo, range, size C1, C2 |- {PList|len _v == X5} <: PList ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x5, x6 C1, C2 |- {PList|len _v == x5} /\ PList ()
lo, range, size, x5, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + x5} /\ {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x3 -> zero]U2 && P1 zero _v) && ((x6 <= _v && _v <= x6 + x5) && (x5 >= 0 && (x5 >= 0 && x5 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x6 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + lo} /\ {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x3 -> zero]U2 && P1 zero _v) && (x6 <= _v && _v <= x6 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons zero (range lo
                      size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons zero
                       (range lo
                          size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons zero
                    (range lo
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), len _v == 1 + len x2, len x4 == lo, len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons zero x4)) == 1 + len x4 && (elems ((Cons zero x4)) == [zero] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (range
                                 lo size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons zero (range lo
                      lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons zero
                       (range lo
                          lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons zero
                    (range lo
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), len _v == 1 + len x2, len x4 == lo, len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons zero x4)) == 1 + len x4 && (elems ((Cons zero x4)) == [zero] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (range
                                 lo lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons zero (range lo
                      zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons zero
                       (range lo
                          zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons zero
                    (range lo
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), len _v == 1 + len x2, len x4 == lo, len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons zero x4)) == 1 + len x4 && (elems ((Cons zero x4)) == [zero] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (range
                                 lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} /\ X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} <: X4:_ -> PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x6 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + zero} /\ {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x3 -> zero]U2 && P1 zero _v) && (x6 <= _v && _v <= x6 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons zero (range zero
                      size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons zero
                       (range zero
                          size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons zero
                    (range zero
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), len _v == 1 + len x2, len x4 == zero, len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons zero x4)) == 1 + len x4 && (elems ((Cons zero x4)) == [zero] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (range
                                 zero size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons zero (range zero
                      lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons zero
                       (range zero
                          lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons zero
                    (range zero
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), len _v == 1 + len x2, len x4 == zero, len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons zero x4)) == 1 + len x4 && (elems ((Cons zero x4)) == [zero] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (range
                                 zero lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x3 -> zero]U2 && P1 zero _v} <P1 _0 _1> ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons zero (range zero
                      zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument Cons zero
                       (range zero
                          zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons zero
                    (range zero
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x3 -> zero]U2} <P1 _0 _1>|_v == (Cons zero x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|[x3 -> zero, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|[x3 -> zero]U2 && P1 zero _v} ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|[x3 -> zero]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero x4), len _v == 1 + len x2, len x4 == zero, len ((Cons zero x4)) == 1 + len x4, elems ((Cons zero x4)) == [zero] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons zero x4)) == 1 + len x4 && (elems ((Cons zero x4)) == [zero] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons zero
                         (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero (range
                                 zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|U2} ()
lo, range, size |- A3
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x1 -> lo]U1 && P0 lo _v) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x1 -> lo]U1 && P0 lo _v) && (x4 <= _v && _v <= x4 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
type substitution before checking []
Checking dec :: X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: Int ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking dec size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
type substitution before checking []
Checking range lo (dec
                     size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       (dec
                          size) of type LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo (dec
                              size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == size - 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == size - 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == size - 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size - 1, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo
RHS: len _v == size
assumption !(size <= 0) && (x4 == size - 1 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         (dec size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec
                                size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking dec lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument dec
                       lo of type {Int|_v == lo - 1}
type substitution before checking []
Checking range lo (dec
                     lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       (dec
                          lo) of type LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo (dec
                              lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == lo - 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == lo - 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == lo - 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == lo - 1, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo
RHS: len _v == size
assumption !(size <= 0) && (x4 == lo - 1 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         (dec lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec lo))
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking dec zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument dec
                       zero of type {Int|_v == zero - 1}
type substitution before checking []
Checking range lo (dec
                     zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       (dec
                          zero) of type LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo (dec
                              zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero - 1, zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo
RHS: len _v == size
assumption !(size <= 0) && (x4 == zero - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         (dec zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec
                                zero))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
type substitution before checking []
Checking inc :: X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 + 1} <: Int ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 + 1} /\ Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking inc size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       size of type {Int|_v == size + 1}
type substitution before checking []
Checking range lo (inc
                     size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       (inc
                          size) of type LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo (inc
                              size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == size + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == size + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == size + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size + 1, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo
RHS: len _v == size
assumption !(size <= 0) && (x4 == size + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         (inc size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc
                                size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking inc lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
type substitution before checking []
Checking range lo (inc
                     lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       (inc
                          lo) of type LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo (inc
                              lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == lo + 1, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo
RHS: len _v == size
assumption !(size <= 0) && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         (inc lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc lo))
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking inc zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       zero of type {Int|_v == zero + 1}
type substitution before checking []
Checking range lo (inc
                     zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range lo
                       (inc
                          zero) of type LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range lo (inc
                              zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero + 1, zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo
RHS: len _v == size
assumption !(size <= 0) && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         (inc zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc
                                zero))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
type substitution before checking []
Checking Cons :: X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Int ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Cons ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (Int) <()>'
with shape 'Int'
when checking range ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else range
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (zero == 0 && (size >= 0 && (([x1 -> lo]U1 && P0 lo _v) && (x4 <= _v && _v <= x4 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
type substitution before checking []
Checking dec :: X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: Int ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking dec size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
type substitution before checking []
Checking range zero (dec
                       size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       (dec
                          size) of type LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    (dec
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == size - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == size - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == size - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size - 1, zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == size - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (dec size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking dec lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument dec
                       lo of type {Int|_v == lo - 1}
type substitution before checking []
Checking range zero (dec
                       lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       (dec
                          lo) of type LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    (dec
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == lo - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == lo - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == lo - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == lo - 1, zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == lo - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (dec lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  lo))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking dec zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument dec
                       zero of type {Int|_v == zero - 1}
type substitution before checking []
Checking range zero (dec
                       zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       (dec
                          zero) of type LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    (dec
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero - 1, zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == zero - 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (dec zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  zero))
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
type substitution before checking []
Checking inc :: X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 + 1} <: Int ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 + 1} /\ Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking inc size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       size of type {Int|_v == size + 1}
type substitution before checking []
Checking range zero (inc
                       size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       (inc
                          size) of type LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    (inc
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == size + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == size + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == size + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size + 1, zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == size + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (inc size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking inc lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
type substitution before checking []
Checking range zero (inc
                       lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       (inc
                          lo) of type LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    (inc
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == lo + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == lo + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == lo + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == lo + 1, zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == lo + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (inc lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  lo))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking inc zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       zero of type {Int|_v == zero + 1}
type substitution before checking []
Checking range zero (inc
                       zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument range zero
                       (inc
                          zero) of type LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range zero
                    (inc
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero + 1, zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (inc zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  zero))
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
type substitution before checking []
Checking Cons :: X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Int ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Cons ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (Int) <()>'
with shape 'Int'
when checking range ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else range
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
type substitution before checking []
Checking Cons :: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
CALL UNIFY FROM lo, range, size, x3, x4 C1, C2 |- A2 /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
UNIFY A2 WITH {Int|[x1 -> lo]U1 && P0 lo _v} PRODUCING {Int|U2}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
type substitution before checking []
Checking dec :: X4:_ -> {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> {Int|U2} ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> {Int|U2} ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: {Int|U2} ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  False ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (U2 && (_v == x5 - 1 && size >= 0)))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking dec size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size - 1 && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec
                 size) :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x3:{Int|_v == size - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x3:{Int|_v == size - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x3:{Int|_v == size - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3 C1, C2 |- {A3|False} <: {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (dec size)
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons (dec
                             size)
                       Nil of type LET x3:({Int|_v == size - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons (dec
                          size)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == size - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == size - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size - 1, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      Nil)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
type substitution before checking []
Checking inc :: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == size - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
type substitution before checking []
Checking dec :: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == size - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
type substitution before checking []
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3, x6, x7 C1, C2 |- A3 /\ {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (x3 == size - 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons lo x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> lo]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> lo]U3 && (x3 == size - 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x6 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec size) (Cons
                            lo
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (Cons lo
                                      Nil) of type LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec
                          size) (Cons lo
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size - 1, x2 == (Cons x3 x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (Cons lo Nil))
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons size x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> size]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> size]U3 && (x3 == size - 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x6 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec size) (Cons
                            size
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (Cons size
                                      Nil) of type LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec
                          size) (Cons size
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size - 1, x2 == (Cons x3 x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (Cons size Nil))
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons zero x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> zero]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> zero]U3 && (x3 == size - 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x6 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec size) (Cons
                            zero
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (Cons zero
                                      Nil) of type LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec
                          size) (Cons zero
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size - 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (Cons zero Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == size - 1 && (size >= 0 && ((U2 && P1 x3 _v) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == size - 1 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec size) (range
                            lo
                            size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (range lo
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          size) (range lo
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size - 1, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (range lo size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec size) (range
                            lo
                            lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (range lo
                                      lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          size) (range lo
                                   lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size - 1, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (range lo lo))
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec size) (range
                            lo
                            zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (range lo
                                      zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          size) (range lo
                                   zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == size - 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec size) (range
                            zero
                            lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (range zero
                                      lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          size) (range zero
                                   lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (range zero lo))
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec size) (range
                            zero
                            size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (range zero
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          size) (range zero
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (range zero size))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec size) (range
                            zero
                            zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             size) (range zero
                                      zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          size) (range zero
                                   zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == size - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               size) (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking dec lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument dec
                       lo of type {Int|_v == lo - 1}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec
                 lo) :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x3:{Int|_v == lo - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x3:{Int|_v == lo - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x3:{Int|_v == lo - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3 C1, C2 |- {A3|False} <: {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (dec lo)
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == lo - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == lo - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons (dec
                             lo)
                       Nil of type LET x3:({Int|_v == lo - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons (dec lo)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == lo - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == lo - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo - 1, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo) Nil)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
type substitution before checking []
Checking inc :: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == lo - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
type substitution before checking []
Checking dec :: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == lo - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
type substitution before checking []
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3, x6, x7 C1, C2 |- A3 /\ {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (x3 == lo - 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons size x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> size]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> size]U3 && (x3 == lo - 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x6 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec lo) (Cons
                          size
                          Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (Cons size
                                    Nil) of type LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec lo)
                    (Cons size
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo - 1, x2 == (Cons x3 x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (Cons size Nil))
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons lo x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> lo]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> lo]U3 && (x3 == lo - 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x6 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec lo) (Cons lo
                          Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (Cons lo
                                    Nil) of type LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec lo)
                    (Cons lo
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo - 1, x2 == (Cons x3 x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (Cons lo Nil))
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons zero x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> zero]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> zero]U3 && (x3 == lo - 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x6 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec lo) (Cons
                          zero
                          Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (Cons zero
                                    Nil) of type LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec lo)
                    (Cons zero
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo - 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (Cons zero Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == lo - 1 && (size >= 0 && ((U2 && P1 x3 _v) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == lo - 1 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec lo) (range lo
                          size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (range lo
                                    size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec lo)
                    (range lo
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo - 1, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (range lo size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec lo) (range lo
                          lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (range lo
                                    lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec lo)
                    (range lo
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo - 1, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (range lo lo))
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec lo) (range lo
                          zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (range lo
                                    zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec lo)
                    (range lo
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec lo) (range
                          zero
                          size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (range zero
                                    size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec lo)
                    (range zero
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (range zero size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec lo) (range
                          zero
                          lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (range zero
                                    lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec lo)
                    (range zero
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (range zero lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec lo) (range
                          zero
                          zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             lo) (range zero
                                    zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec lo)
                    (range zero
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               lo) (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking dec zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument dec
                       zero of type {Int|_v == zero - 1}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec
                 zero) :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x3:{Int|_v == zero - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x3:{Int|_v == zero - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3 C1, C2 |- {A3|False} <: {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (dec zero)
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == zero - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == zero - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons (dec
                             zero)
                       Nil of type LET x3:({Int|_v == zero - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons (dec
                          zero)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == zero - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == zero - 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      Nil)
Trying zero
type substitution before checking []
Checking zero :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x3:{Int|_v == zero - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
type substitution before checking []
Checking inc :: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == zero - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
type substitution before checking []
Checking dec :: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == zero - 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
type substitution before checking []
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3, x6, x7 C1, C2 |- A3 /\ {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (x3 == zero - 1 && (zero == 0 && (size >= 0 && (U2 && P1 x3 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons size x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> size]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> size]U3 && (x3 == zero - 1 && (zero == 0 && (size >= 0 && (U2 && P1 x3 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x6 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec zero) (Cons
                            size
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (Cons size
                                      Nil) of type LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec
                          zero) (Cons size
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (Cons size Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons lo x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> lo]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> lo]U3 && (x3 == zero - 1 && (zero == 0 && (size >= 0 && (U2 && P1 x3 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x6 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec zero) (Cons
                            lo
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (Cons lo
                                      Nil) of type LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec
                          zero) (Cons lo
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (Cons lo Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons zero x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> zero]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> zero]U3 && (x3 == zero - 1 && (zero == 0 && (size >= 0 && (U2 && P1 x3 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x6 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (dec zero) (Cons
                            zero
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (Cons zero
                                      Nil) of type LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (dec
                          zero) (Cons zero
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (Cons zero Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size))))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + lo))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec zero) (range
                            lo
                            size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (range lo
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          zero) (range lo
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (range lo size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec zero) (range
                            lo
                            lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (range lo
                                      lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          zero) (range lo
                                   lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (range lo lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec zero) (range
                            lo
                            zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (range lo
                                      zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          zero) (range lo
                                   zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec zero) (range
                            zero
                            size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (range zero
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          zero) (range zero
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (range zero size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec zero) (range
                            zero
                            lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (range zero
                                      lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          zero) (range zero
                                   lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (range zero lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero - 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (dec zero) (range
                            zero
                            zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (dec
                             zero) (range zero
                                      zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (dec
                          zero) (range zero
                                   zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero - 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero - 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero - 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (dec
                               zero) (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
type substitution before checking []
Checking inc :: X4:_ -> {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> {Int|U2} ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> {Int|U2} ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 + 1} <: {Int|U2} ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 + 1} /\ {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  False ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (U2 && (_v == x5 + 1 && size >= 0)))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking inc size :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size + 1 && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument inc
                       size of type {Int|_v == size + 1}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc
                 size) :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x3:{Int|_v == size + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x3:{Int|_v == size + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x3:{Int|_v == size + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3 C1, C2 |- {A3|False} <: {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc size)
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == size + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == size + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons (inc
                             size)
                       Nil of type LET x3:({Int|_v == size + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons (inc
                          size)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == size + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == size + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size + 1, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      Nil)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
type substitution before checking []
Checking dec :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == size + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
type substitution before checking []
Checking inc :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == size + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
type substitution before checking []
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3, x6, x7 C1, C2 |- A3 /\ {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (x3 == size + 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons lo x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> lo]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> lo]U3 && (x3 == size + 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x6 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc size) (Cons
                            lo
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (Cons lo
                                      Nil) of type LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc
                          size) (Cons lo
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size + 1, x2 == (Cons x3 x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons lo Nil))
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons size x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> size]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> size]U3 && (x3 == size + 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x6 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc size) (Cons
                            size
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (Cons size
                                      Nil) of type LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc
                          size) (Cons size
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size + 1, x2 == (Cons x3 x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size Nil))
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons zero x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> zero]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> zero]U3 && (x3 == size + 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x6 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc size) (Cons
                            zero
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (Cons zero
                                      Nil) of type LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc
                          size) (Cons zero
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons zero Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == size + 1 && (size >= 0 && ((U2 && P1 x3 _v) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == size + 1 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc size) (range
                            lo
                            size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (range lo
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          size) (range lo
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size + 1, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc size) (range
                            lo
                            lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (range lo
                                      lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          size) (range lo
                                   lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size + 1, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo lo))
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc size) (range
                            lo
                            zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (range lo
                                      zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          size) (range lo
                                   zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc size) (range
                            zero
                            lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (range zero
                                      lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          size) (range zero
                                   lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero lo))
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc size) (range
                            zero
                            size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (range zero
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          size) (range zero
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero size))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc size) (range
                            zero
                            zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             size) (range zero
                                      zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          size) (range zero
                                   zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking inc lo :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo + 1 && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc
                 lo) :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x3:{Int|_v == lo + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x3:{Int|_v == lo + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x3:{Int|_v == lo + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3 C1, C2 |- {A3|False} <: {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc lo)
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == lo + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == lo + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons (inc
                             lo)
                       Nil of type LET x3:({Int|_v == lo + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons (inc lo)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == lo + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == lo + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo + 1, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) Nil)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
type substitution before checking []
Checking dec :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == lo + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
type substitution before checking []
Checking inc :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == lo + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
type substitution before checking []
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3, x6, x7 C1, C2 |- A3 /\ {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (x3 == lo + 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons size x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> size]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> size]U3 && (x3 == lo + 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x6 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc lo) (Cons
                          size
                          Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (Cons size
                                    Nil) of type LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc lo)
                    (Cons size
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo + 1, x2 == (Cons x3 x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons size Nil))
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons lo x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> lo]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> lo]U3 && (x3 == lo + 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x6 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc lo) (Cons lo
                          Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (Cons lo
                                    Nil) of type LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc lo)
                    (Cons lo
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo + 1, x2 == (Cons x3 x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons lo Nil))
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons zero x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> zero]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> zero]U3 && (x3 == lo + 1 && (size >= 0 && (U2 && P1 x3 _v)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x6 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc lo) (Cons
                          zero
                          Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (Cons zero
                                    Nil) of type LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc lo)
                    (Cons zero
                       Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons zero Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == lo + 1 && (size >= 0 && ((U2 && P1 x3 _v) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == lo + 1 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc lo) (range lo
                          size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (range lo
                                    size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc lo)
                    (range lo
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo + 1, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc lo) (range lo
                          lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (range lo
                                    lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc lo)
                    (range lo
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo + 1, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo lo))
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc lo) (range lo
                          zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (range lo
                                    zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc lo)
                    (range lo
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc lo) (range
                          zero
                          size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (range zero
                                    size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc lo)
                    (range zero
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc lo) (range
                          zero
                          lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (range zero
                                    lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc lo)
                    (range zero
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc lo) (range
                          zero
                          zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             lo) (range zero
                                    zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc lo)
                    (range zero
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == lo + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking inc zero :: {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U2} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U2} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Synthesized argument inc
                       zero of type {Int|_v == zero + 1}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc
                 zero) :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P0 _0 _1 && P1 _0 _1)))
  C1 && (C2 && (U2 && (size >= 0 && ([x1 -> lo]U1 && P0 lo _v))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
x3:{Int|_v == zero + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
x3:{Int|_v == zero + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3 C1, C2 |- {A3|False} <: {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons (inc zero)
           Nil :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == zero + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == zero + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument Cons (inc
                             zero)
                       Nil of type LET x3:({Int|_v == zero + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}]
Checking Cons lo (Cons (inc
                          zero)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == zero + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == zero + 1}) IN {PList {Int|[x4 -> (Nil)]U2} <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x4 -> (Nil)]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      Nil)
Trying zero
type substitution before checking []
Checking zero :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
x3:{Int|_v == zero + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
type substitution before checking []
Checking dec :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == zero + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
type substitution before checking []
Checking inc :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == zero + 1} -> PList {Int|True && P1 x3 _v} <P1 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
type substitution before checking []
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
CALL UNIFY FROM lo, range, size, x3, x6, x7 C1, C2 |- A3 /\ {Int|U2 && P1 x3 _v} ()
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && (U3 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (U2 && P1 x3 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           size :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> -> {PList {Int|[x6 -> size]U3} <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons size x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> size]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> size]U3 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (U2 && P1 x3 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
UNIFY A4 WITH {Int|[x6 -> size]U3 && P2 size _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> size]U3 && P2 size _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons size
           Nil :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons size
                       Nil of type {PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc zero) (Cons
                            size
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (Cons size
                                      Nil) of type LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc
                          zero) (Cons size
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> size, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (Cons size Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> size]U3 && P2 size _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> size, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 size _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Trying lo
type substitution before checking []
Checking lo :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           lo :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> -> {PList {Int|[x6 -> lo]U3} <P2 _0 _1>|_v == (Cons lo x7)} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons lo x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> lo]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> lo]U3 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (U2 && P1 x3 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
UNIFY A4 WITH {Int|[x6 -> lo]U3 && P2 lo _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> lo]U3 && P2 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo
           Nil :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons lo
                       Nil of type {PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc zero) (Cons
                            lo
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (Cons lo
                                      Nil) of type LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc
                          zero) (Cons lo
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> lo, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons lo (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (Cons lo Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (Cons lo Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> lo]U3 && P2 lo _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> lo, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 lo _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: {Int|U3} ()
lo, range, size |- A4
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|U3} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking [A3 -> {Int|U3}]
Checking Cons
           zero :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> -> {PList {Int|[x6 -> zero]U3} <P2 _0 _1>|_v == (Cons zero x7)} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons zero x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|[x6 -> zero]U3} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (size >= 0 && (P1 _0 _1 && P2 _0 _1)))
  C1 && (C2 && ([x6 -> zero]U3 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (U2 && P1 x3 _v))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
lo, range, size |- A4
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
CALL UNIFY FROM lo, range, size C1, C2 |- {A4|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
UNIFY A4 WITH {Int|[x6 -> zero]U3 && P2 zero _v} PRODUCING {Int|U4}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|[x6 -> zero]U3 && P2 zero _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Nil of type {PList {Int|False} <False>|_v == (Nil)}
type substitution before checking [A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons zero
           Nil :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons zero
                       Nil of type {PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}
type substitution before checking [A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons (inc zero) (Cons
                            zero
                            Nil) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (Cons zero
                                      Nil) of type LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}, A3 -> {Int|U3}, A4 -> {Int|U4}]
Checking Cons lo (Cons (inc
                          zero) (Cons zero
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|[x6 -> zero, x7 -> (Nil)]U3} <P2 _0 _1>|_v == (Cons zero (Nil))}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P2 :: A3 -> A3 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> (Nil)]U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
WARNING: free vars in predicate |- P2 :: A3 -> A3 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}, U3 -> {}, U4 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), x4 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons x3 x4)) == 1 + len x4, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 x4)) == [x3] + elems x4, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (x4 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && (len x2 >= 0 && len x4 >= 0)))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (Cons zero Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (Cons zero Nil))
Trying zero
type substitution before checking []
Checking zero :: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {Int|[x6 -> zero]U3 && P2 zero _v} <P2 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|[x6 -> zero, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|[x6 -> X6, x7 -> X5]U3} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P1 :: A2 -> A2 -> Bool
|- P0 :: A1 -> A1 -> Bool
|- P2 :: A3 -> A3 -> Bool
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
PList {Int|True && P2 zero _v} <P2 _0 _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size))))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 0)
Trying size
type substitution before checking []
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying lo
type substitution before checking []
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + lo))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range lo
           size :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc zero) (range
                            lo
                            size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (range lo
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          zero) (range lo
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (range lo size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range lo
           lo :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc zero) (range
                            lo
                            lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (range lo
                                      lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          zero) (range lo
                                   lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (range lo lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range lo
           zero :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc zero) (range
                            lo
                            zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (range lo
                                      zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          zero) (range lo
                                   zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == lo, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == lo && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + lo))))))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (range lo zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P1 _0 _1)))
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && ((U2 && P1 x3 _v) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking range zero
           size :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc zero) (range
                            zero
                            size) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (range zero
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          zero) (range zero
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero size))
Trying lo
type substitution before checking []
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range zero
           lo :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc zero) (range
                            zero
                            lo) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (range zero
                                      lo) of type LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          zero) (range zero
                                   lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> lo <= _x && _x <= lo + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (range zero lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Trying zero
type substitution before checking []
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
type substitution before checking []
Checking range zero
           zero :: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {Int|U2 && P1 x3 _v} <P1 _0 _1> ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
type substitution before checking [A2 -> {Int|U2}]
Checking Cons (inc zero) (range
                            zero
                            zero) :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (8 0)
Synthesized argument Cons (inc
                             zero) (range zero
                                      zero) of type LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}
type substitution before checking [A1 -> {Int|U1}, A2 -> {Int|U2}]
Checking Cons lo (Cons (inc
                          zero) (range zero
                                   zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == zero + 1}) IN {PList {Int|U2} <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|[x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P1 :: A2 -> A2 -> Bool
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> zero <= _x && _x <= zero + zero)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) (range zero zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
type substitution before checking []
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
type substitution before checking []
Checking Cons :: X5:_ -> X4:_ -> {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> {Int|U2} ()
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> {Int|U2} ()
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> {Int|U2} ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Cons ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X5:_ -> X4:_ -> {Int|U2} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> {Int|U2} ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> {Int|U2} ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> {Int|U2} ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> {Int|U2} ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X2, X3, lo, range, size C1, C2 |- {Int|[x3 -> X3, x4 -> X2]U2} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
|- P1 :: A2 -> A2 -> Bool
TYPE ERROR: Cannot match shape 'PList (Int) <()>'
with shape 'Int'
when checking range ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else range
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
type substitution before checking []
Checking range :: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (size >= 0 && (([x1 -> lo]U1 && P0 lo _v) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
type substitution before checking []
Checking dec :: X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  False ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == x5 - 1 && (size >= 0 && (_v >= 0 && (_v >= 0 && _v < size)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
type substitution before checking []
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument size of type {Int|_v == size}
type substitution before checking []
Checking dec
           size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
  C1 && (C2 && (_v == size - 1 && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
type substitution before checking []
Checking range (dec
                  size) :: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN Int -> LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN Int -> LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN Int -> LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN Int -> LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X2:_ -> PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {PList|len _v == x3} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_0 != _1 && (size >= 0 && P0 _0 _1)))
  C1 && (C2 && (x3 == size - 1 && (size >= 0 && (([x1 -> lo]U1 && P0 lo _v) && (x4 <= _v && _v <= x4 + x3)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying lo
type substitution before checking []
Checking lo :: LET x3:({Int|_v == size - 1}) IN Int in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size - 1}) IN Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size - 1}) IN Int ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|_v == lo} <: Int ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument lo of type {Int|_v == lo}
type substitution before checking []
Checking range (dec size)
           lo :: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|lo <= _v && _v <= lo + x3} <_0 != _1>|len _v == x3} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|lo <= _v && _v <= lo + x3} <_0 != _1>|len _v == x3} <: PList {Int|[x1 -> lo]U1 && P0 lo _v} <P0 _0 _1> ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {PList|len _v == x3} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Synthesized argument range (dec
                              size)
                       lo of type LET x3:({Int|_v == size - 1}) IN {PList {Int|lo <= _v && _v <= lo + x3} <_0 != _1>|len _v == x3}
type substitution before checking [A1 -> {Int|U1}]
Checking Cons lo (range (dec
                           size)
                    lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == size - 1}) IN {PList {Int|lo <= _v && _v <= lo + x3} <_0 != _1>|len _v == x3}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == size - 1}) IN {PList {Int|lo <= _v && _v <= lo + x3} <_0 != _1>|len _v == x3}) IN {PList {Int|[x1 -> lo]U1} <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|[x1 -> lo]U1} <: {Int|lo <= _v && _v <= lo + size} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (len _v == 1 + len x2 && (len x2 == x3 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + x3))))))) ==> len _v == size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Typing Constraints
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
|- P0 :: A1 -> A1 -> Bool
Simple Constraints
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + x3} <: {Int|[x1 -> lo]U1 && P0 lo _v} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
WARNING: free vars in predicate |- P0 :: A1 -> A1 -> Bool
Pred assignments
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= lo + _v, _v <= size + _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Auxiliary goals are:
Re-checking candidates after updating C1
Checking validity
  C1 && (C2 && ([x1 -> X1, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
  C1 && (C2 && ([x1 -> lo]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
  C1 && (C2 && ([x1 -> lo, x2 -> X0]U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
  C1 && (C2 && (_v == lo && size >= 0)) ==> U1
  C1 && (C2 && (_v == size - 1 && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
  C1 && (C2 && (x3 == size - 1 && (len _v == 1 + len x2 && (len x2 == x3 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + x3))))))) ==> len _v == size
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {}, C2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (0)
TYPE ERROR: Re-checking candidates failed
